# Phack Man

## 0. Disclaimer

This document is prone to modifications and will probably be changed during development.

## 1. Overview
### 1.1. Plot
The **INV4D-312** is a transport spaceship that was just intercepted by an alien race classified as the **Zenytp-3D3**. Take control of **Phack Man** in his mission to clear all the floors of the cargo bay from these little bastards.

### 1.2. Gameplay
Phack Man's gameplay resembles the good olâ€™ Pacman mechanics. The map is a generated maze and entities can move freely through it. Phack Man can shoot with Lock & Stock, his loyal twin miniguns. The objective is to collect all

### 1.3. Map
The map is a generated maze with progressive size depending on the floor. The algorithm used is undefined by now, but some ideas arise:

* Use a classic algorithm to create a maze, or even a lib that does this for us.
* Generate small shapes and mirror them horizontally and/or vertically.

We can think of the map like a node graph where nodes are placed at maze positions where the player can turn 90 degrees.

```
# # # # # # # #
# o         o #     # - solid block
#   # # # #   #     o - map node
# o     o #   #
#   # #   #   #
# o     o   o #
# # # # # # # #
```

The walkable path will be 2 tiles width, instead of 1 like in Pac-Man. The walls of the map can have a minimum of 1 tile width.

### 1.4. Input
Straight and simple: **arrows** for **movement** and **space** to **shoot** with Lock&Stock. The player always advance if its facing allows it. This is, the player cannot be stopped in the middle of a path. The player can always turn 180 degrees and interrupt the movement from one node to other.

The event generated by the player pressing an arrow key is saved if the movement is not possible, so that this event can be used when the player reaches a node.

### 1.5. Enemy behaviors

There will be defined a few behaviors, but probably **only one will be implemented** (the easiest) for time economy reasons.

1. **Boring Walker**. Wanders the maze randomly with no meaning of life.  
2. **Curious Chaser**. Wanders the maze randomly until the distance to the player is less than a threshold distance. Then it chases the player until the threshold distance is surpassed.
3. **Speedy**. Wanders the maze chasing the player. Movement is quick from node to node, but there is a resting time in each node.
4. **Insatiable Chaser**. Wanders the maze chasing the player independently from the distance to it.
5. **Unpleasant Snitch**. Wanders the maze randomly and if it detects the player in its range of vision, chases it. Each snitch also notifies other snitches about the player position. This could be improved by notifying boring walkers too.

### 1.6. Possible upgrades

These upgrades won't probably be implemented, but they will be kept here for the record.

* **Lock&Stock mods**. These mods can change the rate, speed, or damage of L&S shoots.
* **Weaknesses and resistances** so that a certain mod can be strong against certain type of enemies and weak against others.
* **Vary enemy colors** to determine its toughness or Weakness&Resistances.

## 2. Map generation

After doing a little of research, I found a really interesting [pacman-like maze generator idea](http://pacman.shaunew.com/play/mapgen/) by Shaun Williams, part of his [Pac-Man tribute project](http://pacman.shaunew.com/). As the author says, the doc is incomplete in details, but the base is **use tetromino shapes to aid on map generation**. The map will be generated following this very principle.

#### Method overview
**Rectangle-made shapes** will be used to build a layout so that we can use the connected edges of those shapes to build the path. Later, this will be rendered into a tile map for its direct use in the game.

A **shape** model will be represented as a 2D matrix of integers. The generation will be supplied with a list of models in order to place them randomly in a blank layout. This way, we are shaping different distributions of the same shapes. Relating this to game progress, a different set of shapes can be used in each floor of the spaceship.

A resume of the needed steps (prone to changes):

* **Generate** a layout from a list of *connected shapes*.
* **Mirror** the resulting layout horizontally.
* **Trace** the path given the layout using shape edges.
* **Render** the path to a tile map and use in the game!

#### Generate layout

Having a list with the wanted shapes, those can be placed in a blank canvas using different strategies. The one I will use is fairly simple: pick a random shape and place it to the left, as in tetris but shapes going left instead of down. The row will be selected randomly.

Currently, if no more pieces fit the blank canvas, an error is thrown and the app is stopped, but we could resolve this by making the map wider and/or trying to use other random row.

#### Extract path

To extract the path, the matrix needs to be scaled x3, so that we can thick the shapes by one tile and get our needed walkable path of 2 tiles wide. Finally, a border will be added and filled with walls, so that we can use the more external paths that are only 1 tile wide.
